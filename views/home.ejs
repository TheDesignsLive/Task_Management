<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Home</title>

<style>

  /* ===== PREVENT FULL PAGE SCROLL ===== */
  html, body {
    margin: 0;
    padding: 0;
     width: 100%;
    height: 100%;
    overflow: hidden;   /*  Prevent page scroll */
    font-family: Arial, sans-serif;
    background-color: #3C3A3A;
  }

  .layout {
    display: flex;
    height: calc(100% - 60px); /*  Adjust if navbar is 60px */
  }

  .sidebar-container {
    width: 55px;
  }

  .main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  .sub-header {
    display: flex;
    background-color: #CDF4F4;
    padding: 6px;
    gap: 10px;
    align-items: center;
    font-size: 14px;
   /* font-weight: 000;*/
  }

  .sub-header .task { flex: 4; padding: 4px; text-align: center; border-radius: 5px; background-color: #CDF4F4; }
  .sub-header .change,
  .sub-header .update { flex: 1.5; padding: 4px; text-align: center; border-radius: 5px; background-color: #CDF4F4; }
  .sub-header .other-task { flex: 2; padding: 4px; text-align: center; border-radius: 5px; background-color: #CDF4F4; }

  /* ===== CONTENT WRAPPER ===== */
  .content-wrapper {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;  /*  important */
  }

  /* ===== TASK SECTION ===== */
  .task-container {
    flex: 1;
    display: flex;
    overflow: hidden;   /*  prevents extra scroll */
  }

  .task-box {
    padding: 10px;
    overflow-y: auto;   /*  Scroll only when content overflows */
  }

  .task-main { flex: 4; }
  .task-change { flex: 1.5; }
  .task-update { flex: 1.5; }
  .task-other { flex: 2; }

  .vertical-line {
    width: 1.5px;
    background-color: #7C7B7B;
    opacity: 0.8;
  }

  /* ===== COMPLETED SECTION (Fixed height) ===== */
  .completed-header {
    margin-left: 10px;
    margin-right: 10px;
    border-radius: 100px;
    background-color: #0F8989;
    padding: 8px 20px;
    font-weight: bold;
    color: white;
    font-size: 14px;
  }

  .completed-section {
    height: 150px;
    overflow-y: auto;  /* Optional scroll for completed */
    padding: 10px;
    background-color: #2E2D2D;
    color: white;
  }
  /* ===== TASK BOX ===== */
.task-item {
  font-size: 13px;
  padding: 4px;
  
  margin: 6px 0;
  background-color: #444;
  color: #fff;
  border-radius: 4px;
  cursor: move;
}

/* Completed Task */
.completed-task {
  opacity: 0.6;
  cursor: default;
}

/* Layout row */
.task-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

/* Checkbox base style */
/* Checkbox base */
.task-checkbox {
  width: 12px;
  height: 12px;
  appearance: none;
  border: 2px solid white; /* default, will be overridden by priority class */
  border-radius: 3px;
  background: transparent;
  cursor: pointer;
  position: relative;
}

/* Checked style: keep border same, show white tick */
.task-checkbox:checked {
  background-color: transparent; /* keep background transparent */
}


.task-checkbox:checked::after {
  content: "âœ”";               
  position: absolute;
  top: 0;
  left: 1px;
  font-size: 7px;
  color: white;               
}


.priority-red { border-color: #ff4d4d; }
.priority-yellow { border-color: #ffd633; }
.priority-blue { border-color: #4da6ff; }

.task-date {
  min-width: 60px;
  text-align: right;
/*  margin-right: auto;*/
  font-size: 11px;    
  opacity: 0.8;        
}

</style>
</head>

<body>
<%- include('navbar') %>

<div class="layout">

  <div class="sidebar-container">
    <% if (show_sidebar === 'sidebar') { %>
      <%- include('sidebar') %>
    <% } else if (show_sidebar === 'Usersidebar') { %>
      <%- include('user_sidebar') %>
    <% } %>
  </div>

  <div class="main-content">

    <div class="sub-header">
      <div class="task">Task</div>
      <div class="change">Change</div>
      <div class="update">Update</div>
      <div class="other-task">Others</div>
    </div>

    <div class="content-wrapper">

      <div class="task-container">

        <div class="task-box task-main" id="task-section"></div>
        <div class="vertical-line"></div>
        <div class="task-box task-change" id="change-section"></div>
        <div class="vertical-line"></div>
        <div class="task-box task-update" id="update-section"></div>
        <div class="vertical-line"></div>
        <div class="task-box task-other" id="other-section"></div>

      </div>

      <div class="completed-header">Completed Tasks</div>
      <div class="completed-section" id="completed-section"></div>

    </div>

  </div>
</div>
<script>
const tasks = <%- JSON.stringify(tasks) %>;

// ===== DATE FORMAT FUNCTION =====
function formatDate(dateStr) {
  if (!dateStr) return '';

  const today = new Date();
  const tomorrow = new Date();
  tomorrow.setDate(today.getDate() + 1);

  const taskDate = new Date(dateStr);

  today.setHours(0,0,0,0);
  tomorrow.setHours(0,0,0,0);
  taskDate.setHours(0,0,0,0);

  if (taskDate.getTime() === today.getTime()) return "Today";
  else if (taskDate.getTime() === tomorrow.getTime()) return "Tom";
  else return taskDate.toLocaleDateString('en-GB', { day: '2-digit', month: 'short' });
}

// ===== PRIORITY CLASS =====
function getPriorityClass(priority) {
  if (!priority) return '';
  if (priority.toUpperCase() === 'HIGH') return 'priority-red';
  if (priority.toUpperCase() === 'MEDIUM') return 'priority-yellow';
  if (priority.toUpperCase() === 'LOW') return 'priority-blue';
  return '';
}

// ===== UPDATE TASK STATUS (returns JSON) =====
async function updateTaskStatus(id, status, section=null) {
  const res = await fetch('/update-task-status', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id, status, section })
  });
  return res.json(); // Updated to return response
}

// ===== UPDATE TASK SECTION =====
function updateTaskSection(id, section) {
  fetch('/update-task-section', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id, section })
  });
}

// ===== CREATE SINGLE TASK ELEMENT =====
function createTaskElement(task) {
  const div = document.createElement('div');
  div.className = 'task-item';
  div.dataset.id = task.id;

  if (task.status === 'COMPLETED') div.classList.add('completed-task');

  const priorityClass = getPriorityClass(task.priority);

  div.innerHTML = `
    <div class="task-row">
      <input type="checkbox"
        class="task-checkbox ${priorityClass}"
        ${task.status === 'COMPLETED' ? 'checked' : ''} />

<span style="flex:1;">
  &nbsp;${task.title}${task.assigned_by_name ? '&emsp;&emsp;' + task.assigned_by_name : ''}
</span>



      <span class="task-date">

        ${formatDate(task.due_date)}
      </span>
    </div>
  `;

  // Only allow drag if task is not completed
  if (task.status !== 'COMPLETED') div.draggable = true;

  // =====  FIXED CHECKBOX HANDLER =====
  const checkbox = div.querySelector('input.task-checkbox');
  checkbox.addEventListener('change', async (e) => {
    const isChecked = e.target.checked;
    const completedSection = document.getElementById('completed-section');
    const taskSection = document.getElementById('task-section');

    if (isChecked) {
      // Move to Completed
      const res = await updateTaskStatus(task.id, 'COMPLETED', 'COMPLETED');
      if(res.success){
        div.classList.add('completed-task');
        div.remove();
        completedSection.appendChild(div);

        // Update task object in tasks array
        const t = tasks.find(tsk => tsk.id == task.id);
        t.status = 'COMPLETED';
        t.section = 'COMPLETED';
      }
    } else {
      // Move back to TASK section
      const res = await updateTaskStatus(task.id, 'OPEN', 'TASK'); // Status OPEN, Section TASK
      if(res.success){
        div.classList.remove('completed-task');
        div.remove();


        //Here i want to refresh page
        window.location.reload();
        // Insert in TASK section in ascending date order
        let inserted = false;
        const taskItems = Array.from(taskSection.querySelectorAll('.task-item'));
        const newTaskDate = t.due_date ? new Date(t.due_date) : null;

        for (let i = 0; i < taskItems.length; i++) {
          const existingTask = tasks.find(tsk => tsk.id == taskItems[i].dataset.id);
          const tDate = existingTask.due_date ? new Date(existingTask.due_date) : null;
          if (!tDate || (newTaskDate && newTaskDate < tDate)) {
            taskSection.insertBefore(div, taskItems[i]);
            inserted = true;
            break;
          }
        }
        if (!inserted) taskSection.appendChild(div);
      }
    }
  });

  return div;
}

// ===== CREATE HORIZONTAL LINE =====
function createSeparator() {
  const hr = document.createElement('div');
  hr.style.height = '1px';
  hr.style.backgroundColor = '#7C7B7B';
  hr.style.margin = '6px 0';
  return hr;
}

//date group
function createDateGroup(dateStr) {

  const wrapper = document.createElement('div');
  wrapper.className = 'date-group';
  wrapper.dataset.date = dateStr;

  const title = document.createElement('div');
  title.style.opacity = "0.8";
  title.style.fontSize = "12px";
  title.style.margin = "6px 0";

  const formatted = formatDate(dateStr);
  title.innerText = formatted;

  const hr = document.createElement('div');
  hr.style.height = "1px";
  hr.style.backgroundColor = "#7C7B7B";
  hr.style.marginBottom = "6px";

  const container = document.createElement('div');
  container.className = "date-task-container";

  wrapper.appendChild(title);
  wrapper.appendChild(hr);
  wrapper.appendChild(container);

  return wrapper;
}

// ===== INIT SECTIONS WITH DATE GROUPING =====
function initSections() {

  const sections = {
    'TASK': document.getElementById('task-section'),
    'CHANGES': document.getElementById('change-section'),
    'UPDATE': document.getElementById('update-section'),
    'OTHERS': document.getElementById('other-section'),
    'COMPLETED': document.getElementById('completed-section')
  };

  const sectionTasks = {
    'TASK': [],
    'CHANGES': [],
    'UPDATE': [],
    'OTHERS': [],
    'COMPLETED': []
  };

  // ===== Separate tasks by section =====
  tasks.forEach(task => {
    const targetSection =
      task.status === 'COMPLETED'
        ? 'COMPLETED'
        : (task.section || 'TASK');

    sectionTasks[targetSection].push(task);
  });

  // ======================================================
  // ðŸ”¥ TASK SECTION (NEW DYNAMIC DATE GROUP LOGIC)
  // ======================================================

  const taskSection = sections['TASK'];
  const taskList = sectionTasks['TASK'];

  let uniqueDates = new Set();

  taskList.forEach(task => {
    if (task.due_date) {
      const d = new Date(task.due_date)
        .toISOString()
        .split('T')[0];
      uniqueDates.add(d);
    }
  });

  // Always add Today & Tomorrow
  const today = new Date();
  const tomorrow = new Date();
  tomorrow.setDate(today.getDate() + 1);

  uniqueDates.add(today.toISOString().split('T')[0]);
  uniqueDates.add(tomorrow.toISOString().split('T')[0]);

  const sortedDates = Array.from(uniqueDates)
    .sort((a, b) => new Date(a) - new Date(b));

  sortedDates.forEach(dateStr => {

    const group = createDateGroup(dateStr);
    const container = group.querySelector('.date-task-container');

    taskList.forEach(task => {
      const taskDate = task.due_date
        ? new Date(task.due_date).toISOString().split('T')[0]
        : null;

      if (taskDate === dateStr) {
        const el = createTaskElement(task);
        container.appendChild(el);
      }
    });

    taskSection.appendChild(group);
  });

  // ======================================================
  // ðŸ”¥ OTHER SECTIONS (OLD LOGIC UNCHANGED)
  // ======================================================

  ['CHANGES', 'UPDATE', 'OTHERS'].forEach(sec => {

    const taskList = sectionTasks[sec];
    if (!taskList.length) return;

    const taskGroups = {};
    const noDateTasks = [];

    taskList.forEach(task => {
      const dateKey = task.due_date
        ? new Date(task.due_date).toDateString()
        : null;

      if (!dateKey) {
        noDateTasks.push(task);
      } else {
        if (!taskGroups[dateKey]) {
          taskGroups[dateKey] = [];
        }
        taskGroups[dateKey].push(task);
      }
    });

    const sortedDates = Object.keys(taskGroups)
      .sort((a, b) => new Date(a) - new Date(b));

    sortedDates.forEach(dateStr => {
      appendTasksToContainer(
        sections[sec],
        taskGroups[dateStr]
      );
    });

    appendTasksToContainer(
      sections[sec],
      noDateTasks
    );

  });

  // ======================================================
  // ðŸ”¥ COMPLETED SECTION
  // ======================================================

  sectionTasks['COMPLETED'].forEach(task => {
    const el = createTaskElement(task);
    sections['COMPLETED'].appendChild(el);
  });

}

// ===== APPEND TASK ARRAY TO CONTAINER =====
function appendTasksToContainer(container, taskArray) {
  taskArray.forEach(task => {
    const el = createTaskElement(task);
    container.appendChild(el);
  });
  if(taskArray.length>0) container.appendChild(createSeparator());
}

// ===== DRAG & DROP =====
function enableDragAndDrop() {

  document.querySelectorAll('.task-item').forEach(item => {
    item.addEventListener('dragstart', () => {
      item.classList.add('dragging');
    });

    item.addEventListener('dragend', () => {
      item.classList.remove('dragging');
    });
  });

  document.querySelectorAll('.date-group').forEach(group => {

    group.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    group.addEventListener('drop', async (e) => {
      e.preventDefault();

      const dragging = document.querySelector('.dragging');
      if (!dragging) return;

      const taskId = dragging.dataset.id;
      const newDate = group.dataset.date;

      const res = await fetch('/update-task-date', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: taskId, due_date: newDate })
      });

      const data = await res.json();

      if (data.success) {
        window.location.reload();
      }
    });

  });
}

  document.querySelectorAll('.task-item').forEach(item => {
    if(item.draggable) {
      item.addEventListener('dragstart', ()=> item.classList.add('dragging'));
      item.addEventListener('dragend', ()=> item.classList.remove('dragging'));
    }
  });

  Object.keys(containers).forEach(containerId => {
    const container = document.getElementById(containerId);
    container.addEventListener('dragover', e=> e.preventDefault());
    container.addEventListener('drop', e=> {
      e.preventDefault();
      const dragging = document.querySelector('.dragging');
      if(!dragging) return;
      container.appendChild(dragging);
      updateTaskSection(dragging.dataset.id, containers[containerId]);
    });
  });
}

document.addEventListener('DOMContentLoaded', ()=>{
  initSections();
  enableDragAndDrop();
});
</script>


</body>
</html>